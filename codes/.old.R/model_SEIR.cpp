// Code generated by Stan version 2.19.1

#include <stan/model/model_header.hpp>

namespace model546826a057b0_model_SEIR_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model546826a057b0_model_SEIR");
    reader.add_event(264, 262, "end", "model546826a057b0_model_SEIR");
    return reader;
}

template <typename T0__>
typename boost::math::tools::promote_args<T0__>::type
maxEigen(const Eigen::Matrix<T0__, Eigen::Dynamic, Eigen::Dynamic>& M, std::ostream* pstream__);

template <typename T0__>
std::vector<std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic> > >
scale_contact(const T0__& pWorkOpen,
                  const int& nAgeGroups, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 4;
        validate_non_negative_index("CM", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("CM", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("CM", "6", 6);
        validate_non_negative_index("CM", "4", 4);
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  >  > CM(6, std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >(4, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups)));
        stan::math::initialize(CM, DUMMY_VAR__);
        stan::math::fill(CM, DUMMY_VAR__);
        stan::math::assign(CM,static_cast<std::vector<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > > >(stan::math::array_builder<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >().add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(1, 16))).array())).add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.1, 16))).add(diag_matrix(rep_vector(0, 16))).add(diag_matrix(rep_vector(.1, 16))).array())).add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.5, 16))).add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.1, 16))).array())).add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.5, 16))).add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.1, 16))).array())).add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(pWorkOpen, 16))).add(diag_matrix(rep_vector(0, 16))).add(diag_matrix(rep_vector(.1, 16))).array())).add(static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(diag_matrix(rep_vector(1, 16))).add(diag_matrix(rep_vector(.8, 16))).add(diag_matrix(rep_vector(.8, 16))).add(diag_matrix(rep_vector(.6, 16))).array())).array()));


        current_statement_begin__ = 44;
        return stan::math::promote_scalar<fun_return_scalar_t__>(CM);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct scale_contact_functor__ {
    template <typename T0__>
        std::vector<std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__>::type, Eigen::Dynamic, Eigen::Dynamic> > >
    operator()(const T0__& pWorkOpen,
                  const int& nAgeGroups, std::ostream* pstream__) const {
        return scale_contact(pWorkOpen, nAgeGroups, pstream__);
    }
};

template <typename T0__, typename T2__, typename T4__, typename T5__>
typename boost::math::tools::promote_args<T0__, T2__, T4__, T5__>::type
get_beta(const T0__& R0,
             const int& nAgeGroups,
             const T2__& gamma,
             const int& calculate_transmission_probability,
             const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& POP,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& contact_matrix, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T4__, T5__>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 55;
        validate_non_negative_index("constraints_base", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("constraints_base", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("constraints_base", "4", 4);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > constraints_base(4, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups));
        stan::math::initialize(constraints_base, DUMMY_VAR__);
        stan::math::fill(constraints_base, DUMMY_VAR__);

        current_statement_begin__ = 56;
        local_scalar_t__ TOTALPOP(DUMMY_VAR__);
        (void) TOTALPOP;  // dummy to suppress unused var warning
        stan::math::initialize(TOTALPOP, DUMMY_VAR__);
        stan::math::fill(TOTALPOP, DUMMY_VAR__);
        stan::math::assign(TOTALPOP,sum(POP));

        current_statement_begin__ = 57;
        validate_non_negative_index("pAge", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> pAge(nAgeGroups);
        stan::math::initialize(pAge, DUMMY_VAR__);
        stan::math::fill(pAge, DUMMY_VAR__);
        stan::math::assign(pAge,divide(POP, TOTALPOP));

        current_statement_begin__ = 59;
        validate_non_negative_index("mC", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("mC", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("mC", "4", 4);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > mC(4, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups));
        stan::math::initialize(mC, DUMMY_VAR__);
        stan::math::fill(mC, DUMMY_VAR__);

        current_statement_begin__ = 61;
        local_scalar_t__ beta(DUMMY_VAR__);
        (void) beta;  // dummy to suppress unused var warning
        stan::math::initialize(beta, DUMMY_VAR__);
        stan::math::fill(beta, DUMMY_VAR__);

        current_statement_begin__ = 63;
        validate_non_negative_index("x", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("x", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> x(nAgeGroups, nAgeGroups);
        stan::math::initialize(x, DUMMY_VAR__);
        stan::math::fill(x, DUMMY_VAR__);

        current_statement_begin__ = 64;
        validate_non_negative_index("Csym", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("Csym", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> Csym(nAgeGroups, nAgeGroups);
        stan::math::initialize(Csym, DUMMY_VAR__);
        stan::math::fill(Csym, DUMMY_VAR__);

        current_statement_begin__ = 65;
        validate_non_negative_index("C", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("C", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C(nAgeGroups, nAgeGroups);
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);
        stan::math::assign(C,rep_matrix(0, nAgeGroups, nAgeGroups));


        current_statement_begin__ = 67;
        for (int i = 1; i <= 4; ++i) {

            current_statement_begin__ = 68;
            stan::model::assign(constraints_base, 
                        stan::model::cons_list(stan::model::index_uni(i), stan::model::nil_index_list()), 
                        diag_matrix(rep_vector(1, nAgeGroups)), 
                        "assigning variable constraints_base");
            current_statement_begin__ = 69;
            stan::math::assign(x, get_base1(contact_matrix, i, "contact_matrix", 1));
            current_statement_begin__ = 70;
            stan::math::assign(Csym, divide(add(x, elt_multiply(transpose(x), multiply(pAge, transpose(elt_divide(1.0, pAge))))), 2));
            current_statement_begin__ = 73;
            stan::math::assign(C, add(C, multiply(Csym, get_base1(constraints_base, i, "constraints_base", 1))));
        }
        current_statement_begin__ = 76;
        if (as_bool(logical_eq(calculate_transmission_probability, 1))) {
            {
            current_statement_begin__ = 77;
            validate_non_negative_index("M", "nAgeGroups", nAgeGroups);
            validate_non_negative_index("M", "nAgeGroups", nAgeGroups);
            Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> M(nAgeGroups, nAgeGroups);
            stan::math::initialize(M, DUMMY_VAR__);
            stan::math::fill(M, DUMMY_VAR__);
            stan::math::assign(M,C);


            current_statement_begin__ = 78;
            for (int i = 1; i <= nAgeGroups; ++i) {

                current_statement_begin__ = 79;
                for (int j = 1; j <= nAgeGroups; ++j) {

                    current_statement_begin__ = 80;
                    stan::model::assign(M, 
                                stan::model::cons_list(stan::model::index_uni(i), stan::model::cons_list(stan::model::index_uni(j), stan::model::nil_index_list())), 
                                ((get_base1(pAge, i, "pAge", 1) / get_base1(pAge, j, "pAge", 1)) * get_base1(C, i, j, "C", 1)), 
                                "assigning variable M");
                }
            }
            current_statement_begin__ = 85;
            stan::math::assign(beta, ((R0 * gamma) / maxEigen(M, pstream__)));
            }
        } else {
            current_statement_begin__ = 86;
            stan::math::assign(beta, .025);
        }
        current_statement_begin__ = 88;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_beta_functor__ {
    template <typename T0__, typename T2__, typename T4__, typename T5__>
        typename boost::math::tools::promote_args<T0__, T2__, T4__, T5__>::type
    operator()(const T0__& R0,
             const int& nAgeGroups,
             const T2__& gamma,
             const int& calculate_transmission_probability,
             const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& POP,
             const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic, Eigen::Dynamic> >& contact_matrix, std::ostream* pstream__) const {
        return get_beta(R0, nAgeGroups, gamma, calculate_transmission_probability, POP, contact_matrix, pstream__);
    }
};

template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T6__, typename T7__, typename T8__, typename T12__>
std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T12__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
simulate_SEIR(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& POP,
                  const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& initialI,
                  const T2__& R0,
                  const T3__& R0postoutbreak,
                  const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& rho,
                  const int& nDaySim,
                  const T6__& DurInf,
                  const T7__& DurLat,
                  const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& contact_matrix,
                  const int& tStartIntenseIntervention,
                  const int& nIntenseStages,
                  const std::vector<int>& IntenseStagesWeeks,
                  const std::vector<T12__>& pWorkOpen,
                  const int& tCloseSchool,
                  const int& tReopenSchool, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T12__>::type>::type>::type local_scalar_t__;
    typedef local_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 97;
        local_scalar_t__ gamma(DUMMY_VAR__);
        (void) gamma;  // dummy to suppress unused var warning
        stan::math::initialize(gamma, DUMMY_VAR__);
        stan::math::fill(gamma, DUMMY_VAR__);
        stan::math::assign(gamma,(1 - stan::math::exp((-(1) / DurInf))));

        current_statement_begin__ = 98;
        local_scalar_t__ alpha(DUMMY_VAR__);
        (void) alpha;  // dummy to suppress unused var warning
        stan::math::initialize(alpha, DUMMY_VAR__);
        stan::math::fill(alpha, DUMMY_VAR__);
        stan::math::assign(alpha,(1 - stan::math::exp((-(1) / DurLat))));

        current_statement_begin__ = 99;
        int tmax(0);
        (void) tmax;  // dummy to suppress unused var warning
        stan::math::fill(tmax, std::numeric_limits<int>::min());
        stan::math::assign(tmax,nDaySim);

        current_statement_begin__ = 100;
        int dt(0);
        (void) dt;  // dummy to suppress unused var warning
        stan::math::fill(dt, std::numeric_limits<int>::min());
        stan::math::assign(dt,1);

        current_statement_begin__ = 101;
        int nSteps(0);
        (void) nSteps;  // dummy to suppress unused var warning
        stan::math::fill(nSteps, std::numeric_limits<int>::min());
        stan::math::assign(nSteps,nDaySim);

        current_statement_begin__ = 102;
        int tStopIntenseIntervention(0);
        (void) tStopIntenseIntervention;  // dummy to suppress unused var warning
        stan::math::fill(tStopIntenseIntervention, std::numeric_limits<int>::min());
        stan::math::assign(tStopIntenseIntervention,(tStartIntenseIntervention + sum(IntenseStagesWeeks)));

        current_statement_begin__ = 104;
        int nAgeGroups(0);
        (void) nAgeGroups;  // dummy to suppress unused var warning
        stan::math::fill(nAgeGroups, std::numeric_limits<int>::min());
        stan::math::assign(nAgeGroups,get_base1(dims(POP), 1, "dims(POP)", 1));

        current_statement_begin__ = 105;
        validate_non_negative_index("numExposed", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> numExposed(nAgeGroups);
        stan::math::initialize(numExposed, DUMMY_VAR__);
        stan::math::fill(numExposed, DUMMY_VAR__);

        current_statement_begin__ = 106;
        validate_non_negative_index("numInfected", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> numInfected(nAgeGroups);
        stan::math::initialize(numInfected, DUMMY_VAR__);
        stan::math::fill(numInfected, DUMMY_VAR__);

        current_statement_begin__ = 107;
        validate_non_negative_index("numRecovery", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> numRecovery(nAgeGroups);
        stan::math::initialize(numRecovery, DUMMY_VAR__);
        stan::math::fill(numRecovery, DUMMY_VAR__);

        current_statement_begin__ = 108;
        validate_non_negative_index("numReported", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, 1, Eigen::Dynamic> numReported(nAgeGroups);
        stan::math::initialize(numReported, DUMMY_VAR__);
        stan::math::fill(numReported, DUMMY_VAR__);

        current_statement_begin__ = 109;
        validate_non_negative_index("S", "nSteps", nSteps);
        validate_non_negative_index("S", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> S(nSteps, nAgeGroups);
        stan::math::initialize(S, DUMMY_VAR__);
        stan::math::fill(S, DUMMY_VAR__);

        current_statement_begin__ = 110;
        validate_non_negative_index("I", "nSteps", nSteps);
        validate_non_negative_index("I", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> I(nSteps, nAgeGroups);
        stan::math::initialize(I, DUMMY_VAR__);
        stan::math::fill(I, DUMMY_VAR__);

        current_statement_begin__ = 111;
        validate_non_negative_index("E", "nSteps", nSteps);
        validate_non_negative_index("E", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> E(nSteps, nAgeGroups);
        stan::math::initialize(E, DUMMY_VAR__);
        stan::math::fill(E, DUMMY_VAR__);

        current_statement_begin__ = 112;
        validate_non_negative_index("R", "nSteps", nSteps);
        validate_non_negative_index("R", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> R(nSteps, nAgeGroups);
        stan::math::initialize(R, DUMMY_VAR__);
        stan::math::fill(R, DUMMY_VAR__);

        current_statement_begin__ = 113;
        validate_non_negative_index("H", "nSteps", nSteps);
        validate_non_negative_index("H", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> H(nSteps, nAgeGroups);
        stan::math::initialize(H, DUMMY_VAR__);
        stan::math::fill(H, DUMMY_VAR__);

        current_statement_begin__ = 114;
        validate_non_negative_index("lambda", "nSteps", nSteps);
        validate_non_negative_index("lambda", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> lambda(nSteps, nAgeGroups);
        stan::math::initialize(lambda, DUMMY_VAR__);
        stan::math::fill(lambda, DUMMY_VAR__);

        current_statement_begin__ = 115;
        validate_non_negative_index("incidence", "nSteps", nSteps);
        validate_non_negative_index("incidence", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> incidence(nSteps, nAgeGroups);
        stan::math::initialize(incidence, DUMMY_VAR__);
        stan::math::fill(incidence, DUMMY_VAR__);

        current_statement_begin__ = 116;
        validate_non_negative_index("reported", "nSteps", nSteps);
        validate_non_negative_index("reported", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> reported(nSteps, nAgeGroups);
        stan::math::initialize(reported, DUMMY_VAR__);
        stan::math::fill(reported, DUMMY_VAR__);

        current_statement_begin__ = 117;
        validate_non_negative_index("cumulativeIncidence", "nSteps", nSteps);
        validate_non_negative_index("cumulativeIncidence", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> cumulativeIncidence(nSteps, nAgeGroups);
        stan::math::initialize(cumulativeIncidence, DUMMY_VAR__);
        stan::math::fill(cumulativeIncidence, DUMMY_VAR__);

        current_statement_begin__ = 118;
        validate_non_negative_index("time", "nSteps", nSteps);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> time(nSteps);
        stan::math::initialize(time, DUMMY_VAR__);
        stan::math::fill(time, DUMMY_VAR__);

        current_statement_begin__ = 119;
        validate_non_negative_index("pWork", "nSteps", nSteps);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, 1> pWork(nSteps);
        stan::math::initialize(pWork, DUMMY_VAR__);
        stan::math::fill(pWork, DUMMY_VAR__);

        current_statement_begin__ = 120;
        local_scalar_t__ beta(DUMMY_VAR__);
        (void) beta;  // dummy to suppress unused var warning
        stan::math::initialize(beta, DUMMY_VAR__);
        stan::math::fill(beta, DUMMY_VAR__);

        current_statement_begin__ = 121;
        local_scalar_t__ beta_postfirstwave(DUMMY_VAR__);
        (void) beta_postfirstwave;  // dummy to suppress unused var warning
        stan::math::initialize(beta_postfirstwave, DUMMY_VAR__);
        stan::math::fill(beta_postfirstwave, DUMMY_VAR__);

        current_statement_begin__ = 122;
        validate_non_negative_index("constraintsIntervention", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("constraintsIntervention", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("constraintsIntervention", "6", 6);
        validate_non_negative_index("constraintsIntervention", "4", 4);
        std::vector<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  >  > constraintsIntervention(6, std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >(4, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups)));
        stan::math::initialize(constraintsIntervention, DUMMY_VAR__);
        stan::math::fill(constraintsIntervention, DUMMY_VAR__);

        current_statement_begin__ = 123;
        validate_non_negative_index("CONTRAINTS", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("CONTRAINTS", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("CONTRAINTS", "4", 4);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > CONTRAINTS(4, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups));
        stan::math::initialize(CONTRAINTS, DUMMY_VAR__);
        stan::math::fill(CONTRAINTS, DUMMY_VAR__);

        current_statement_begin__ = 124;
        validate_non_negative_index("C", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("C", "nAgeGroups", nAgeGroups);
        Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> C(nAgeGroups, nAgeGroups);
        stan::math::initialize(C, DUMMY_VAR__);
        stan::math::fill(C, DUMMY_VAR__);

        current_statement_begin__ = 126;
        validate_non_negative_index("output", "nSteps", nSteps);
        validate_non_negative_index("output", "nAgeGroups", nAgeGroups);
        validate_non_negative_index("output", "7", 7);
        std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>  > output(7, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nSteps, nAgeGroups));
        stan::math::initialize(output, DUMMY_VAR__);
        stan::math::fill(output, DUMMY_VAR__);


        current_statement_begin__ = 129;
        stan::math::assign(S, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 130;
        stan::math::assign(E, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 131;
        stan::math::assign(I, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 132;
        stan::math::assign(R, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 133;
        stan::math::assign(H, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 134;
        stan::math::assign(lambda, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 135;
        stan::math::assign(incidence, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 136;
        stan::math::assign(reported, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 137;
        stan::math::assign(cumulativeIncidence, rep_matrix(0, nSteps, nAgeGroups));
        current_statement_begin__ = 138;
        stan::math::assign(time, rep_vector(0, nSteps));
        current_statement_begin__ = 140;
        stan::model::assign(I, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                    transpose(initialI), 
                    "assigning variable I");
        current_statement_begin__ = 141;
        stan::model::assign(S, 
                    stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                    subtract(transpose(POP), stan::model::rvalue(I, stan::model::cons_list(stan::model::index_uni(1), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "I")), 
                    "assigning variable S");
        current_statement_begin__ = 144;
        stan::math::assign(pWork, rep_vector(1, nSteps));
        current_statement_begin__ = 145;
        for (int i = 1; i <= get_base1(dims(IntenseStagesWeeks), 1, "dims(IntenseStagesWeeks)", 1); ++i) {
            {
            current_statement_begin__ = 146;
            int a(0);
            (void) a;  // dummy to suppress unused var warning
            stan::math::fill(a, std::numeric_limits<int>::min());
            stan::math::assign(a,(logical_eq(i, 1) ? tStartIntenseIntervention : (tStartIntenseIntervention + (sum(stan::model::rvalue(IntenseStagesWeeks, stan::model::cons_list(stan::model::index_min_max(1, (i - 1)), stan::model::nil_index_list()), "IntenseStagesWeeks")) * 7)) ));


            current_statement_begin__ = 147;
            stan::model::assign(pWork, 
                        stan::model::cons_list(stan::model::index_min_max(a, ((a + (get_base1(IntenseStagesWeeks, i, "IntenseStagesWeeks", 1) * 7)) - 1)), stan::model::nil_index_list()), 
                        rep_vector(get_base1(pWorkOpen, i, "pWorkOpen", 1), (get_base1(IntenseStagesWeeks, i, "IntenseStagesWeeks", 1) * 7)), 
                        "assigning variable pWork");
            }
        }
        current_statement_begin__ = 151;
        stan::math::assign(beta, get_beta(R0, nAgeGroups, gamma, 1, POP, contact_matrix, pstream__));
        current_statement_begin__ = 152;
        stan::math::assign(beta_postfirstwave, (logical_lt(get_base1(pWorkOpen, 2, "pWorkOpen", 1), 1) ? stan::math::promote_scalar<local_scalar_t__>(get_beta(R0postoutbreak, nAgeGroups, gamma, 1, POP, contact_matrix, pstream__)) : stan::math::promote_scalar<local_scalar_t__>(beta) ));
        current_statement_begin__ = 153;
        for (int s = 1; s <= (nSteps - 1); ++s) {

            current_statement_begin__ = 154;
            stan::math::assign(constraintsIntervention, scale_contact(get_base1(pWork, s, "pWork", 1), nAgeGroups, pstream__));
            current_statement_begin__ = 157;
            if (as_bool((primitive_value(logical_lt(get_base1(time, s, "time", 1), tCloseSchool)) || primitive_value(logical_gte(get_base1(time, s, "time", 1), tReopenSchool))))) {

                current_statement_begin__ = 158;
                if (as_bool(logical_lt(get_base1(time, s, "time", 1), tStartIntenseIntervention))) {

                    current_statement_begin__ = 159;
                    stan::math::assign(CONTRAINTS, get_base1(constraintsIntervention, 1, "constraintsIntervention", 1));
                } else if (as_bool((primitive_value(logical_gte(get_base1(time, s, "time", 1), tStartIntenseIntervention)) && primitive_value(logical_lt(get_base1(time, s, "time", 1), tStopIntenseIntervention))))) {

                    current_statement_begin__ = 161;
                    stan::math::assign(CONTRAINTS, get_base1(constraintsIntervention, 4, "constraintsIntervention", 1));
                } else {

                    current_statement_begin__ = 163;
                    stan::math::assign(CONTRAINTS, get_base1(constraintsIntervention, 6, "constraintsIntervention", 1));
                }
            } else {

                current_statement_begin__ = 166;
                if (as_bool((primitive_value(logical_lt(get_base1(time, s, "time", 1), tStartIntenseIntervention)) || primitive_value(logical_gte(get_base1(time, s, "time", 1), tStopIntenseIntervention))))) {

                    current_statement_begin__ = 167;
                    stan::math::assign(CONTRAINTS, get_base1(constraintsIntervention, 2, "constraintsIntervention", 1));
                } else {

                    current_statement_begin__ = 169;
                    stan::math::assign(CONTRAINTS, get_base1(constraintsIntervention, 5, "constraintsIntervention", 1));
                }
            }
            current_statement_begin__ = 173;
            stan::math::assign(C, add(add(add(multiply(get_base1(CONTRAINTS, 1, "CONTRAINTS", 1), get_base1(contact_matrix, 1, "contact_matrix", 1)), multiply(get_base1(CONTRAINTS, 2, "CONTRAINTS", 1), get_base1(contact_matrix, 2, "contact_matrix", 1))), multiply(get_base1(CONTRAINTS, 3, "CONTRAINTS", 1), get_base1(contact_matrix, 3, "contact_matrix", 1))), multiply(get_base1(CONTRAINTS, 4, "CONTRAINTS", 1), get_base1(contact_matrix, 4, "contact_matrix", 1))));
            current_statement_begin__ = 179;
            stan::model::assign(lambda, 
                        stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        (logical_lt(get_base1(time, s, "time", 1), tStopIntenseIntervention) ? stan::math::promote_scalar<local_scalar_t__>(transpose(multiply(beta, multiply(C, transpose(elt_divide(stan::model::rvalue(I, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "I"), transpose(POP))))))) : stan::math::promote_scalar<local_scalar_t__>(transpose(multiply(beta_postfirstwave, multiply(C, transpose(elt_divide(stan::model::rvalue(I, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "I"), transpose(POP))))))) ), 
                        "assigning variable lambda");
            current_statement_begin__ = 182;
            stan::math::assign(numExposed, multiply(elt_multiply(stan::model::rvalue(lambda, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "lambda"), stan::model::rvalue(S, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "S")), dt));
            current_statement_begin__ = 183;
            stan::math::assign(numInfected, multiply(multiply(alpha, stan::model::rvalue(E, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "E")), dt));
            current_statement_begin__ = 184;
            stan::math::assign(numRecovery, multiply(multiply(gamma, stan::model::rvalue(I, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "I")), dt));
            current_statement_begin__ = 185;
            stan::math::assign(numReported, multiply(numInfected, get_base1(rho, s, "rho", 1)));
            current_statement_begin__ = 187;
            stan::model::assign(S, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        stan::model::deep_copy(subtract(stan::model::rvalue(S, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "S"), numExposed)), 
                        "assigning variable S");
            current_statement_begin__ = 188;
            stan::model::assign(E, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        stan::model::deep_copy(subtract(add(stan::model::rvalue(E, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "E"), numExposed), numInfected)), 
                        "assigning variable E");
            current_statement_begin__ = 189;
            stan::model::assign(I, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        stan::model::deep_copy(subtract(add(stan::model::rvalue(I, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "I"), numInfected), numRecovery)), 
                        "assigning variable I");
            current_statement_begin__ = 190;
            stan::model::assign(R, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        stan::model::deep_copy(add(stan::model::rvalue(R, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "R"), numRecovery)), 
                        "assigning variable R");
            current_statement_begin__ = 191;
            stan::model::assign(H, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        stan::model::deep_copy(add(stan::model::rvalue(H, stan::model::cons_list(stan::model::index_uni(s), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), "H"), numReported)), 
                        "assigning variable H");
            current_statement_begin__ = 192;
            stan::model::assign(incidence, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        divide(numInfected, dt), 
                        "assigning variable incidence");
            current_statement_begin__ = 193;
            stan::model::assign(reported, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::cons_list(stan::model::index_omni(), stan::model::nil_index_list())), 
                        divide(numReported, dt), 
                        "assigning variable reported");
            current_statement_begin__ = 194;
            stan::model::assign(time, 
                        stan::model::cons_list(stan::model::index_uni((s + 1)), stan::model::nil_index_list()), 
                        (get_base1(time, s, "time", 1) + dt), 
                        "assigning variable time");
        }
        current_statement_begin__ = 197;
        stan::math::assign(output, static_cast<std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > >(stan::math::array_builder<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> >().add(S).add(E).add(I).add(R).add(lambda).add(incidence).add(reported).array()));
        current_statement_begin__ = 198;
        return stan::math::promote_scalar<fun_return_scalar_t__>(output);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct simulate_SEIR_functor__ {
    template <typename T0__, typename T1__, typename T2__, typename T3__, typename T4__, typename T6__, typename T7__, typename T8__, typename T12__>
        std::vector<Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T1__, T2__, T3__, typename boost::math::tools::promote_args<T4__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T12__>::type>::type>::type, Eigen::Dynamic, Eigen::Dynamic> >
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic, 1>& POP,
                  const Eigen::Matrix<T1__, Eigen::Dynamic, 1>& initialI,
                  const T2__& R0,
                  const T3__& R0postoutbreak,
                  const Eigen::Matrix<T4__, Eigen::Dynamic, 1>& rho,
                  const int& nDaySim,
                  const T6__& DurInf,
                  const T7__& DurLat,
                  const std::vector<Eigen::Matrix<T8__, Eigen::Dynamic, Eigen::Dynamic> >& contact_matrix,
                  const int& tStartIntenseIntervention,
                  const int& nIntenseStages,
                  const std::vector<int>& IntenseStagesWeeks,
                  const std::vector<T12__>& pWorkOpen,
                  const int& tCloseSchool,
                  const int& tReopenSchool, std::ostream* pstream__) const {
        return simulate_SEIR(POP, initialI, R0, R0postoutbreak, rho, nDaySim, DurInf, DurLat, contact_matrix, tStartIntenseIntervention, nIntenseStages, IntenseStagesWeeks, pWorkOpen, tCloseSchool, tReopenSchool, pstream__);
    }
};

class model546826a057b0_model_SEIR : public prob_grad {
private:
        int nDaySim;
        int mean_DurInf;
        int mean_DurLat;
        double mean_R0;
        double s_R0;
        double mean_R0postoutbreak;
        double s_R0postoutbreak;
        int nAgeGroups;
        vector_d POP;
        vector_d initialI;
        std::vector<matrix_d> contact_matrix;
        vector_d rho;
        int tStartIntenseIntervention;
        int nIntenseStages;
        std::vector<int> IntenseStageWeeks;
        std::vector<double> pWorkOpen;
        int tCloseSchool;
        int tReopenSchool;
public:
    model546826a057b0_model_SEIR(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model546826a057b0_model_SEIR(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        typedef double local_scalar_t__;

        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model546826a057b0_model_SEIR_namespace::model546826a057b0_model_SEIR";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            // initialize data block variables from context__
            current_statement_begin__ = 203;
            context__.validate_dims("data initialization", "nDaySim", "int", context__.to_vec());
            nDaySim = int(0);
            vals_i__ = context__.vals_i("nDaySim");
            pos__ = 0;
            nDaySim = vals_i__[pos__++];

            current_statement_begin__ = 204;
            context__.validate_dims("data initialization", "mean_DurInf", "int", context__.to_vec());
            mean_DurInf = int(0);
            vals_i__ = context__.vals_i("mean_DurInf");
            pos__ = 0;
            mean_DurInf = vals_i__[pos__++];

            current_statement_begin__ = 205;
            context__.validate_dims("data initialization", "mean_DurLat", "int", context__.to_vec());
            mean_DurLat = int(0);
            vals_i__ = context__.vals_i("mean_DurLat");
            pos__ = 0;
            mean_DurLat = vals_i__[pos__++];

            current_statement_begin__ = 206;
            context__.validate_dims("data initialization", "mean_R0", "double", context__.to_vec());
            mean_R0 = double(0);
            vals_r__ = context__.vals_r("mean_R0");
            pos__ = 0;
            mean_R0 = vals_r__[pos__++];
            check_greater_or_equal(function__, "mean_R0", mean_R0, 0);

            current_statement_begin__ = 206;
            context__.validate_dims("data initialization", "s_R0", "double", context__.to_vec());
            s_R0 = double(0);
            vals_r__ = context__.vals_r("s_R0");
            pos__ = 0;
            s_R0 = vals_r__[pos__++];
            check_greater_or_equal(function__, "s_R0", s_R0, 0);

            current_statement_begin__ = 207;
            context__.validate_dims("data initialization", "mean_R0postoutbreak", "double", context__.to_vec());
            mean_R0postoutbreak = double(0);
            vals_r__ = context__.vals_r("mean_R0postoutbreak");
            pos__ = 0;
            mean_R0postoutbreak = vals_r__[pos__++];
            check_greater_or_equal(function__, "mean_R0postoutbreak", mean_R0postoutbreak, 0);

            current_statement_begin__ = 207;
            context__.validate_dims("data initialization", "s_R0postoutbreak", "double", context__.to_vec());
            s_R0postoutbreak = double(0);
            vals_r__ = context__.vals_r("s_R0postoutbreak");
            pos__ = 0;
            s_R0postoutbreak = vals_r__[pos__++];
            check_greater_or_equal(function__, "s_R0postoutbreak", s_R0postoutbreak, 0);

            current_statement_begin__ = 209;
            context__.validate_dims("data initialization", "nAgeGroups", "int", context__.to_vec());
            nAgeGroups = int(0);
            vals_i__ = context__.vals_i("nAgeGroups");
            pos__ = 0;
            nAgeGroups = vals_i__[pos__++];
            check_greater_or_equal(function__, "nAgeGroups", nAgeGroups, 1);

            current_statement_begin__ = 210;
            validate_non_negative_index("POP", "nAgeGroups", nAgeGroups);
            context__.validate_dims("data initialization", "POP", "vector_d", context__.to_vec(nAgeGroups));
            POP = Eigen::Matrix<double, Eigen::Dynamic, 1>(nAgeGroups);
            vals_r__ = context__.vals_r("POP");
            pos__ = 0;
            size_t POP_j_1_max__ = nAgeGroups;
            for (size_t j_1__ = 0; j_1__ < POP_j_1_max__; ++j_1__) {
                POP(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "POP", POP, 0);

            current_statement_begin__ = 211;
            validate_non_negative_index("initialI", "nAgeGroups", nAgeGroups);
            context__.validate_dims("data initialization", "initialI", "vector_d", context__.to_vec(nAgeGroups));
            initialI = Eigen::Matrix<double, Eigen::Dynamic, 1>(nAgeGroups);
            vals_r__ = context__.vals_r("initialI");
            pos__ = 0;
            size_t initialI_j_1_max__ = nAgeGroups;
            for (size_t j_1__ = 0; j_1__ < initialI_j_1_max__; ++j_1__) {
                initialI(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "initialI", initialI, 0);

            current_statement_begin__ = 212;
            validate_non_negative_index("contact_matrix", "nAgeGroups", nAgeGroups);
            validate_non_negative_index("contact_matrix", "nAgeGroups", nAgeGroups);
            validate_non_negative_index("contact_matrix", "4", 4);
            context__.validate_dims("data initialization", "contact_matrix", "matrix_d", context__.to_vec(4,nAgeGroups,nAgeGroups));
            contact_matrix = std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> >(4, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(nAgeGroups, nAgeGroups));
            vals_r__ = context__.vals_r("contact_matrix");
            pos__ = 0;
            size_t contact_matrix_j_2_max__ = nAgeGroups;
            size_t contact_matrix_j_1_max__ = nAgeGroups;
            size_t contact_matrix_k_0_max__ = 4;
            for (size_t j_2__ = 0; j_2__ < contact_matrix_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < contact_matrix_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < contact_matrix_k_0_max__; ++k_0__) {
                        contact_matrix[k_0__](j_1__, j_2__) = vals_r__[pos__++];
                    }
                }
            }

            current_statement_begin__ = 213;
            validate_non_negative_index("rho", "nDaySim", nDaySim);
            context__.validate_dims("data initialization", "rho", "vector_d", context__.to_vec(nDaySim));
            rho = Eigen::Matrix<double, Eigen::Dynamic, 1>(nDaySim);
            vals_r__ = context__.vals_r("rho");
            pos__ = 0;
            size_t rho_j_1_max__ = nDaySim;
            for (size_t j_1__ = 0; j_1__ < rho_j_1_max__; ++j_1__) {
                rho(j_1__) = vals_r__[pos__++];
            }
            check_greater_or_equal(function__, "rho", rho, 0);
            check_less_or_equal(function__, "rho", rho, 1);

            current_statement_begin__ = 215;
            context__.validate_dims("data initialization", "tStartIntenseIntervention", "int", context__.to_vec());
            tStartIntenseIntervention = int(0);
            vals_i__ = context__.vals_i("tStartIntenseIntervention");
            pos__ = 0;
            tStartIntenseIntervention = vals_i__[pos__++];
            check_greater_or_equal(function__, "tStartIntenseIntervention", tStartIntenseIntervention, 0);

            current_statement_begin__ = 216;
            context__.validate_dims("data initialization", "nIntenseStages", "int", context__.to_vec());
            nIntenseStages = int(0);
            vals_i__ = context__.vals_i("nIntenseStages");
            pos__ = 0;
            nIntenseStages = vals_i__[pos__++];
            check_greater_or_equal(function__, "nIntenseStages", nIntenseStages, 1);

            current_statement_begin__ = 217;
            validate_non_negative_index("IntenseStageWeeks", "nIntenseStages", nIntenseStages);
            context__.validate_dims("data initialization", "IntenseStageWeeks", "int", context__.to_vec(nIntenseStages));
            IntenseStageWeeks = std::vector<int>(nIntenseStages, int(0));
            vals_i__ = context__.vals_i("IntenseStageWeeks");
            pos__ = 0;
            size_t IntenseStageWeeks_k_0_max__ = nIntenseStages;
            for (size_t k_0__ = 0; k_0__ < IntenseStageWeeks_k_0_max__; ++k_0__) {
                IntenseStageWeeks[k_0__] = vals_i__[pos__++];
            }
            size_t IntenseStageWeeks_i_0_max__ = nIntenseStages;
            for (size_t i_0__ = 0; i_0__ < IntenseStageWeeks_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "IntenseStageWeeks[i_0__]", IntenseStageWeeks[i_0__], 0);
            }

            current_statement_begin__ = 218;
            validate_non_negative_index("pWorkOpen", "nIntenseStages", nIntenseStages);
            context__.validate_dims("data initialization", "pWorkOpen", "double", context__.to_vec(nIntenseStages));
            pWorkOpen = std::vector<double>(nIntenseStages, double(0));
            vals_r__ = context__.vals_r("pWorkOpen");
            pos__ = 0;
            size_t pWorkOpen_k_0_max__ = nIntenseStages;
            for (size_t k_0__ = 0; k_0__ < pWorkOpen_k_0_max__; ++k_0__) {
                pWorkOpen[k_0__] = vals_r__[pos__++];
            }
            size_t pWorkOpen_i_0_max__ = nIntenseStages;
            for (size_t i_0__ = 0; i_0__ < pWorkOpen_i_0_max__; ++i_0__) {
                check_greater_or_equal(function__, "pWorkOpen[i_0__]", pWorkOpen[i_0__], 0);
                check_less_or_equal(function__, "pWorkOpen[i_0__]", pWorkOpen[i_0__], 1);
            }

            current_statement_begin__ = 220;
            context__.validate_dims("data initialization", "tCloseSchool", "int", context__.to_vec());
            tCloseSchool = int(0);
            vals_i__ = context__.vals_i("tCloseSchool");
            pos__ = 0;
            tCloseSchool = vals_i__[pos__++];
            check_greater_or_equal(function__, "tCloseSchool", tCloseSchool, 0);

            current_statement_begin__ = 221;
            context__.validate_dims("data initialization", "tReopenSchool", "int", context__.to_vec());
            tReopenSchool = int(0);
            vals_i__ = context__.vals_i("tReopenSchool");
            pos__ = 0;
            tReopenSchool = vals_i__[pos__++];
            check_greater_or_equal(function__, "tReopenSchool", tReopenSchool, 0);


            // initialize transformed data variables
            // execute transformed data statements

            // validate transformed data

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 225;
            num_params_r__ += 1;
            current_statement_begin__ = 226;
            num_params_r__ += 1;
            current_statement_begin__ = 227;
            num_params_r__ += 1;
            current_statement_begin__ = 228;
            num_params_r__ += 1;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model546826a057b0_model_SEIR() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        typedef double local_scalar_t__;
        stan::io::writer<double> writer__(params_r__, params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        current_statement_begin__ = 225;
        if (!(context__.contains_r("R0")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable R0 missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("R0");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "R0", "double", context__.to_vec());
        double R0(0);
        R0 = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(R0);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable R0: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 226;
        if (!(context__.contains_r("R0postoutbreak")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable R0postoutbreak missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("R0postoutbreak");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "R0postoutbreak", "double", context__.to_vec());
        double R0postoutbreak(0);
        R0postoutbreak = vals_r__[pos__++];
        try {
            writer__.scalar_unconstrain(R0postoutbreak);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable R0postoutbreak: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 227;
        if (!(context__.contains_r("DurInf")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable DurInf missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("DurInf");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "DurInf", "double", context__.to_vec());
        double DurInf(0);
        DurInf = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(1, DurInf);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable DurInf: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        current_statement_begin__ = 228;
        if (!(context__.contains_r("DurLat")))
            stan::lang::rethrow_located(std::runtime_error(std::string("Variable DurLat missing")), current_statement_begin__, prog_reader__());
        vals_r__ = context__.vals_r("DurLat");
        pos__ = 0U;
        context__.validate_dims("parameter initialization", "DurLat", "double", context__.to_vec());
        double DurLat(0);
        DurLat = vals_r__[pos__++];
        try {
            writer__.scalar_lb_unconstrain(1, DurLat);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(std::runtime_error(std::string("Error transforming variable DurLat: ") + e.what()), current_statement_begin__, prog_reader__());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double, Eigen::Dynamic, 1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(std::vector<T__>& params_r__,
                 std::vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        typedef T__ local_scalar_t__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // dummy to suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;
        try {
            stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);

            // model parameters
            current_statement_begin__ = 225;
            local_scalar_t__ R0;
            (void) R0;  // dummy to suppress unused var warning
            if (jacobian__)
                R0 = in__.scalar_constrain(lp__);
            else
                R0 = in__.scalar_constrain();

            current_statement_begin__ = 226;
            local_scalar_t__ R0postoutbreak;
            (void) R0postoutbreak;  // dummy to suppress unused var warning
            if (jacobian__)
                R0postoutbreak = in__.scalar_constrain(lp__);
            else
                R0postoutbreak = in__.scalar_constrain();

            current_statement_begin__ = 227;
            local_scalar_t__ DurInf;
            (void) DurInf;  // dummy to suppress unused var warning
            if (jacobian__)
                DurInf = in__.scalar_lb_constrain(1, lp__);
            else
                DurInf = in__.scalar_lb_constrain(1);

            current_statement_begin__ = 228;
            local_scalar_t__ DurLat;
            (void) DurLat;  // dummy to suppress unused var warning
            if (jacobian__)
                DurLat = in__.scalar_lb_constrain(1, lp__);
            else
                DurLat = in__.scalar_lb_constrain(1);

            // transformed parameters
            current_statement_begin__ = 232;
            validate_non_negative_index("SEIR", "nDaySim", nDaySim);
            validate_non_negative_index("SEIR", "nAgeGroups", nAgeGroups);
            validate_non_negative_index("SEIR", "7", 7);
            std::vector<Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic> > SEIR(7, Eigen::Matrix<local_scalar_t__, Eigen::Dynamic, Eigen::Dynamic>(nDaySim, nAgeGroups));
            stan::math::initialize(SEIR, DUMMY_VAR__);
            stan::math::fill(SEIR, DUMMY_VAR__);
            stan::math::assign(SEIR,simulate_SEIR(POP, initialI, R0, R0postoutbreak, rho, nDaySim, DurInf, DurLat, contact_matrix, tStartIntenseIntervention, nIntenseStages, IntenseStageWeeks, pWorkOpen, tCloseSchool, tReopenSchool, pstream__));

            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            current_statement_begin__ = 232;
            size_t SEIR_k_0_max__ = 7;
            size_t SEIR_j_1_max__ = nDaySim;
            size_t SEIR_j_2_max__ = nAgeGroups;
            for (size_t k_0__ = 0; k_0__ < SEIR_k_0_max__; ++k_0__) {
                for (size_t j_1__ = 0; j_1__ < SEIR_j_1_max__; ++j_1__) {
                    for (size_t j_2__ = 0; j_2__ < SEIR_j_2_max__; ++j_2__) {
                        if (stan::math::is_uninitialized(SEIR[k_0__](j_1__, j_2__))) {
                            std::stringstream msg__;
                            msg__ << "Undefined transformed parameter: SEIR" << "[" << k_0__ << "]" << "(" << j_1__ << ", " << j_2__ << ")";
                            stan::lang::rethrow_located(std::runtime_error(std::string("Error initializing variable SEIR: ") + msg__.str()), current_statement_begin__, prog_reader__());
                        }
                    }
                }
            }

            // model body
            {
            current_statement_begin__ = 239;
            local_scalar_t__ lnR0(DUMMY_VAR__);
            (void) lnR0;  // dummy to suppress unused var warning
            stan::math::initialize(lnR0, DUMMY_VAR__);
            stan::math::fill(lnR0, DUMMY_VAR__);
            stan::math::assign(lnR0,stan::math::log(R0));

            current_statement_begin__ = 240;
            local_scalar_t__ lnR0postoutbreak(DUMMY_VAR__);
            (void) lnR0postoutbreak;  // dummy to suppress unused var warning
            stan::math::initialize(lnR0postoutbreak, DUMMY_VAR__);
            stan::math::fill(lnR0postoutbreak, DUMMY_VAR__);
            stan::math::assign(lnR0postoutbreak,stan::math::log(R0postoutbreak));


            current_statement_begin__ = 241;
            lp_accum__.add(normal_log<propto__>(lnR0, stan::math::log(mean_R0), stan::math::log(s_R0)));
            current_statement_begin__ = 242;
            lp_accum__.add(normal_log<propto__>(lnR0postoutbreak, stan::math::log(mean_R0postoutbreak), stan::math::log(s_R0postoutbreak)));
            current_statement_begin__ = 243;
            lp_accum__.add(exponential_log<propto__>(DurInf, mean_DurInf));
            if (DurInf < 1) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-exponential_ccdf_log(1, mean_DurInf));
            current_statement_begin__ = 244;
            lp_accum__.add(exponential_log<propto__>(DurLat, mean_DurLat));
            if (DurLat < 1) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else if (DurLat > 30) lp_accum__.add(-std::numeric_limits<double>::infinity());
            else lp_accum__.add(-log_diff_exp(exponential_cdf_log(30, mean_DurLat), exponential_cdf_log(1, mean_DurLat)));
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("R0");
        names__.push_back("R0postoutbreak");
        names__.push_back("DurInf");
        names__.push_back("DurLat");
        names__.push_back("SEIR");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(7);
        dims__.push_back(nDaySim);
        dims__.push_back(nAgeGroups);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        typedef double local_scalar_t__;

        vars__.resize(0);
        stan::io::reader<local_scalar_t__> in__(params_r__, params_i__);
        static const char* function__ = "model546826a057b0_model_SEIR_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning

        // read-transform, write parameters
        double R0 = in__.scalar_constrain();
        vars__.push_back(R0);

        double R0postoutbreak = in__.scalar_constrain();
        vars__.push_back(R0postoutbreak);

        double DurInf = in__.scalar_lb_constrain(1);
        vars__.push_back(DurInf);

        double DurLat = in__.scalar_lb_constrain(1);
        vars__.push_back(DurLat);

        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        local_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        if (!include_tparams__ && !include_gqs__) return;

        try {
            // declare and define transformed parameters
            current_statement_begin__ = 232;
            validate_non_negative_index("SEIR", "nDaySim", nDaySim);
            validate_non_negative_index("SEIR", "nAgeGroups", nAgeGroups);
            validate_non_negative_index("SEIR", "7", 7);
            std::vector<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic> > SEIR(7, Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>(nDaySim, nAgeGroups));
            stan::math::initialize(SEIR, DUMMY_VAR__);
            stan::math::fill(SEIR, DUMMY_VAR__);
            stan::math::assign(SEIR,simulate_SEIR(POP, initialI, R0, R0postoutbreak, rho, nDaySim, DurInf, DurLat, contact_matrix, tStartIntenseIntervention, nIntenseStages, IntenseStageWeeks, pWorkOpen, tCloseSchool, tReopenSchool, pstream__));

            if (!include_gqs__ && !include_tparams__) return;
            // validate transformed parameters
            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning

            // write transformed parameters
            if (include_tparams__) {
                size_t SEIR_j_2_max__ = nAgeGroups;
                size_t SEIR_j_1_max__ = nDaySim;
                size_t SEIR_k_0_max__ = 7;
                for (size_t j_2__ = 0; j_2__ < SEIR_j_2_max__; ++j_2__) {
                    for (size_t j_1__ = 0; j_1__ < SEIR_j_1_max__; ++j_1__) {
                        for (size_t k_0__ = 0; k_0__ < SEIR_k_0_max__; ++k_0__) {
                            vars__.push_back(SEIR[k_0__](j_1__, j_2__));
                        }
                    }
                }
            }
            if (!include_gqs__) return;
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng, params_r_vec, params_i_vec, vars_vec, include_tparams, include_gqs, pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model546826a057b0_model_SEIR";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0postoutbreak";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "DurInf";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "DurLat";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t SEIR_j_2_max__ = nAgeGroups;
            size_t SEIR_j_1_max__ = nDaySim;
            size_t SEIR_k_0_max__ = 7;
            for (size_t j_2__ = 0; j_2__ < SEIR_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < SEIR_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < SEIR_k_0_max__; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "SEIR" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "R0postoutbreak";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "DurInf";
        param_names__.push_back(param_name_stream__.str());
        param_name_stream__.str(std::string());
        param_name_stream__ << "DurLat";
        param_names__.push_back(param_name_stream__.str());

        if (!include_gqs__ && !include_tparams__) return;

        if (include_tparams__) {
            size_t SEIR_j_2_max__ = nAgeGroups;
            size_t SEIR_j_1_max__ = nDaySim;
            size_t SEIR_k_0_max__ = 7;
            for (size_t j_2__ = 0; j_2__ < SEIR_j_2_max__; ++j_2__) {
                for (size_t j_1__ = 0; j_1__ < SEIR_j_1_max__; ++j_1__) {
                    for (size_t k_0__ = 0; k_0__ < SEIR_k_0_max__; ++k_0__) {
                        param_name_stream__.str(std::string());
                        param_name_stream__ << "SEIR" << '.' << k_0__ + 1 << '.' << j_1__ + 1 << '.' << j_2__ + 1;
                        param_names__.push_back(param_name_stream__.str());
                    }
                }
            }
        }

        if (!include_gqs__) return;
    }

}; // model

}  // namespace

typedef model546826a057b0_model_SEIR_namespace::model546826a057b0_model_SEIR stan_model;


